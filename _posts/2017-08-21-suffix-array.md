---
layout: post
title:  "Суффиксный массив"
permalink: suffix-array
date:   2017-08-21 02:07:41 +0300
categories: algorithm
---

### Определение

Пусть задан алфавит $\Sigma$, и на его элементах введено отношение полного порядка. Примерами такого алфавита могут служить латинские буквы с алфавитным порядком или цифры.

Будем говорить, что строка $s$ лексикографически строго меньше строки $p$, если выполнено одно из двух свойств:
1. $\| s \| < \| p \|$, и $s$ являеется префиксом $p$;
2. существует целое число $0 \le k < min(\| s \|, \| p \|)$ такое, что префиксы длины $k$ у строк $s$ и $p$ совпадают, а $s[k] < p[k]$ (здесь и далее используется 0-индексация строк).

Это определение совпадает с житейским понятием алфавитного порядка на словах: меньше то слово, у которого первый несовпадающий символ меньше.

Пусть теперь задана строка $s$ длины $n$. Мы можем выписать все её префиксы и лексикографически отсортировать их. Каждый суффикс задаётся индексом своего начала, поэтому результат такой сортировки можно записать как перестановку чисел от $0$ до $n-1$. Эта перестановка называется суффиксным массивом строки $s$.

Например, суффиксным массивом строки $abracadabra$ будет перестановка $[10, 7, 0, 3, 5, 8, 1, 4, 6, 9, 2]$.

Заметим, что длины всех суффиксов различны, поэтому они все попарно неравны, а значит суффиксный массив определён однозначно.

### Тривиальный алгоритм

Если бы мы умели сравнивать два суффикса за время $T(n)$, то суффиксный массив можно было бы построить за время $O(n \log n \cdot T(n))$ обычной сортировкой. Сравнение строк за $O(n)$ даёт нам алгоритм за $O(n^2 \log n)$. Но если сравнивать суффиксы с помощью полиномиальный хешей и бинарного поиска, то $T(n) = O(\log n)$ и время построения суффиксного массива составит $O(n \log ^{2} n)$.

### Сортировка циклических сдвигов за $O(n \log n)$

Сперва рассмотрим немного другую задачу, хоть и очень похожую. $k$-м циклическом сдвигом строки $s$ назовём строку $s[k:]+s[:k]$, то есть строку, полученную из s переносом первого символа в конец $k$ раз. Наша задача &mdash; отсортировать циклические сдвиги строки, то есть построить суффиксный массив, в котором суффиксы рассматриваются как циклические. Циклические сдвиги могут полностью совпадать, поэтому порядок не определён однозначно; нас устроит любой правильный вариант.

Далее в описании алгоритма подразумевается циклическая индексация: $s[n] = s[0]$, $s[l:r] = s[l:] + s[:(r - n)]$, если $(l < n < r < 2 \cdot n)$ и т.д.

Алгоритм будет состоять из нескольких фаз, после $k$-й фазы будут правильно отсортированы циклические подстроки длины $2^{k}$. Очевидно, что после $\lceil \log n \rceil$ фаз будут правильно отсортированы циклические сдвиги. Если каждую фазу выполнять за $O(n)$, то общее время работы алгоритма составит $O(n \log n)$.

Кроме самого порядка сортировки (далее будем называть его суффиксным массивом) мы будем поддерживать разбиение подстрок на классы эквивалентности: для каждой позиции будет храниться номер его класса эквивалентности, одинаковые номера говорят о том, что подстроки, начинающиеся в данных позициях, равны; разные номера &mdash; не равны. Более того, меньший номер класса эквивалентности будет у меньшей подстроки.

#### Нулевая фаза

Нам надо отсортировать подстроки длины $2^0=1$, то есть символы. Это можно было бы сделать и за $O(n \log n)$, не ломая при этом общую асимптотику алгоритма. Однако обычно размер алфавита не превосходит размер строки, поэтому сортировку символов можно сделать подсчётом за $O(n + \| \Sigma \|)$.

После сортировки надо разбить символы на классы эквивалентности. Для этого мы скажем, что у $0$-го элемента суффиксного массива класс эквивалентности $0$, а потом для каждого следующего элемента суффиксного массива будем проставлять такой же класс, как и предыдущему, если они равны, и на $1$ больший иначе.

#### $(k+1)$-я фаза на основе $k$-й

Сейчас по плану мы должны отсортировать подстроки длины $2^{k+1}$. Каждая такая подстрока имеет вид $s[p:p+2^{k+1}] = s[p:p+2^{k}] + s[(p+2^{k}):(p+2^{k})+2^{k}]$. То есть сортировка таких подстрок &mdash; то же самое, что и сортировка пар из их половинок. Но половинки мы уже отсортировали в предыдущей фазе, и даже присвоили им порядковые номера классов эквивалентности. Поэтому сортировку пар строчек можно заменить на сортировку пар чисел (номеров классов эквивалентности). Для этого можно применить поразрядную сортировку: сначала отсортировать пары по второму элементу, а потом по первому, но уже стабильно. Номера классов эквивалентности у нас до $n$, поэтому сортировать можно подсчётом за $O(n)$. На самом деле, по второму элементу пары мы уже (почти) посортировали в предыдущей фазе: суффиксный массив и является такой сортировкой, только у нас записаны индексы начал именно вторых половин подстрок, а не самих подстрок.

После сортировки нужно снова проставить классы эквивалентности, делать мы будем это так же, как и на нулевой фазе. Конечно, сравнивать на равенство нужно не подстроки длины $2^{k+1}$, а пары номеров старых классов эквивалентности половинок.

### Код

{% highlight cpp linenos %}
const int N = 100100;
const int A = 26;
int n;
char s[N];
int SA[N], newSA[N];
int classId[N], newClassId[N];
int cnt[N];

void buildSA()
{
	for (int i = 0; i <= A; i++)
		cnt[i] = 0;
	for (int i = 0; i < n; i++)
		cnt[(int)(s[i] - 'a') + 1]++;
	for (int i = 1; i <= A; i++)
		cnt[i] += cnt[i - 1];
	for (int i = 0; i < n; i++)
		SA[cnt[(int)(s[i] - 'a')]++] = i;
	classId[SA[0]] = 0;
	for (int i = 1; i < n; i++) {
		classId[SA[i]] = classId[SA[i - 1]];
		if (s[SA[i]] != s[SA[i - 1]])
			classId[SA[i]]++;
	}
	for (int len = 1; len < n; len <<= 1) {
		for (int i = 0; i <= n; i++)
			cnt[i] = 0;
		for (int i = 0; i < n; i++) {
			int p = (SA[i] - len + n) % n;
			cnt[classId[p] + 1]++;
		}
		for (int i = 1; i <= n; i++)
			cnt[i] += cnt[i - 1];
		for (int i = 0; i < n; i++) {
			int p = (SA[i] - len + n) % n;
			newSA[cnt[classId[p]]++] = p;
		}
		for (int i = 0; i < n; i++)
			SA[i] = newSA[i];
		newClassId[SA[0]] = 0;
		for (int i = 1; i < n; i++) {
			int p1 = SA[i - 1], p2 = SA[i];
			int q1 = (p1 + len) % n, q2 = (q2 + len) % n;
			newClassId[p2] = newClassId[p1];
			if (classId[p1] != classId[p2] || classId[q1] != classId[q2])
				newClassId[p1]++;
		}
		for (int i = 0; i < n; i++)
			classId[i] = newClassId[i];
	}
}
{% endhighlight %}

### Настоящий суффиксный массив

Казалось бы, суффиксы сравниваются как раз как циклические сдвиги, но это не совсем правда. Суффиксный массив строки $caba$ должен быть $[3, 1, 2, 0]$, а мы построим $[1, 3, 2, 0]$. Для строчки $aaaaa$ правильная сортировка циклических сдвигов &mdash; это любая перестановка чисел от $0$ до $4$; в то время как суффиксный массив определён однозначно. В чём же дело?

Причина в том, что если мы сравниваем два суффикса и дошли до конца строчки, то мы должны сразу более короткую из строк объявить меньшей, а вот соответствующие циклические сдвиги мы должны сравнивать дальше. Чтобы эмулировать такое поведение, припишем в конец $s$ символ, который заведомо меньше всех символов $s$. Традиционно в качестве таких символов используют \\$ или #. Теперь все циклические сдвиги будут разными (потому что \\$ там встречается в разных местах), причём если префиксы двух циклических строк до первого \\$ совпадают, то меньше будет тот из них, в котором \\$ раньше, то есть тот, который соответствует более короткому суффиксу.

В результате мы получим правильный суффиксный массив, за одним исключением: мы добавили фиктивный суффикс \\$, который соответствует пустому суффиксу $s$. Очевидно, что он меньше всех остальных суффиксов, поэтому чтобы его убрать нужно просто удалить начальный элемент суффиксного массива.

### Массив LCP

Массив LCP &mdash; это массив длины $n-1$, $i$-й элемент которого &mdash; это длина наибольшего общего префикса (Longest Common Prefix, LCP) суффиксов, начинающихся в позициях $SA[i]$ и $SA[i+1]$, то есть соседних в порядке сортировки.

#### Зачем он нужен

Было бы неплохо уметь искать длину общего префикса любых двух суффиксов, а не только соседних в каком-то непонятном порядке. Утверждается, что массив LCP может нам в этом сильно помочь.

Рассмотрим два суффикса, у одного позиция в суффиксном массиве &mdash; это $p$, у другого &mdash; $q$, $p < q$. Пусть их общий префикс имеет длину $L$. Тогда все суффиксы, позиции которых в суффиксном массиве между $p$ и $q$, также будут иметь такой же префикс длины $L$, потому что иначе они не могли бы быть между нашими двумя суффиксами в порядке сортировки. Таким образом, $\forall t \in [p, q) L \le LCP[t]$ Пусть теперь $L' = min(LCP[p], LCP[p+1], \ldots, LCP[q-1])$. Это значит, что префикс длины $L'$ является общим для суффиксов $SA[p]$ и $SA[p+1]$, и для $SA[p+1]$ и $SA[p+2]$, и т.д. до $SA[q-1]$ и $SA[q]$. Но из этого следует, что для $SA[p]$ и $SA[q]$ префикс длины $L'$ тоже является общим. Отсюда $L \le min(LCP[p], LCP[p+1], \ldots, LCP[q-1]) = L' \le L$, а значит $L = L'$. Таким образом, чтобы найти LCP двух произвольных суффиксов, нужно просто взять минимум на отрезке массива LCP между позициями вхождений этих суффиксов в суффиксный массив.

#### Алгоритм Касаи и др.

Пусть $SA[t] = p$, $SA[t+1] = q$, при этом $LCP[t] ( = LCP(s[p:], s[q:]) ) \ge 2$. Посмотрим теперь на суффиксы с началом в $(p+1)$ и $(q+1)$. Каждый из них получен отбрасыванием первого символа у суффиксов с началами $p$ и $q$, соответственно. Длина этих суффиксов была хотя бы $2$, значит наши суффиксы непустые. У суффиксов с началами в $p$ и $q$ был общий префикс длиной $LCP[t]$, значит у наших суффиксов есть общий префикс длиной хотя бы $LCP[t]-1$. Да что там хотя бы! Мы точно знали, что следующие символы различаются, при этом у суффикса с началом в $p$ следующий символ был меньше (чтобы не думать о конце строчки, будем считать, что там фиктивный \\$). Поэтому у суффиксов с началом в $(p+1)$ и $(q+1)$ длина общего префикса ровно $LCP[t]-1$, и суффикс с началом в $(p+1)$ меньше, то есть идёт раньше в суффиксном массиве. Пусть его позиция там &mdash; $u$, а позиция суффикса с началом в $(q+1)$ &mdash; $v$. Тогда мы знаем, что $min(LCP[u], LCP[u+1], \ldots, LCP[v-1]) = LCP[t] - 1$. Но это значит, что $LCP[u] \ge LCP[t] - 1$.

Отсюда идея алгоритма: будем вычислять массив LCP не в порядке суффиксного массива, а в порядке самих суффиксов. Для реализации нам потребуется перестановка, обратная к суффиксному массиву.

{% highlight cpp linenos %}
const int N = 100100;
int n;
char s[N];
int SA[N];
int revSA[N];
int LCP[N];

void buildLCP()
{
	for (int i = 0; i < n; i++)
		revSA[SA[i]] = i;
	int curLCP = 0;
	for (int i = 0; i < n; i++) {
		int p = revSA[i];
		if (p == n - 1) {
			LCP[p] = curLCP = 0;
			continue;
		}
		int q = SA[p + 1];
		curLCP--;
		if (curLCP < 0) curLCP = 0;
		while(i + curLCP < n && q + curLCP < n && s[i + curLCP] == s[q + curLCP])
			curLCP++;
		LCP[p] = curLCP;
	}
}
{% endhighlight %}

Единственное место, время работы которого может вызывать сомнения &mdash; это внутренний цикл while. Однако заметим, что на каждой его итерации значение $curLCP$ увеличивается на $1$, а количество таких увеличений может превосходить количество уменьшений не более чем на $2n$. Количество уменьшений равно $n$; следовательно, алгоритм работает за $O(n)$ (при условии уже построенного суффиксного массива).

#### Замечания

Обычно мы хотим узнавать LCP для любой пары суффиксов. Как мы уже выяснили, для этого нужно брать минимум на отрезке. В данном случае чаще всего для этих целей используют sparse table, так как никаких изменений точно не будет, а на построение суффиксного массива мы все равно уже потратили $O(n \log n)$ времени. Зато на запросы мы будем отвечать за $O(1)$.